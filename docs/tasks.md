# **タスクリスト - Project Anima**

## **フェーズ0: 開発環境準備**

### **[x] 0.1. Python環境構築**

* **タスク内容**: Pythonの仮想環境（例: venv）を構築する。 
* **完了条件**:  
  * 仮想環境が作成され、アクティベートできること。  
  * requirements.txt または pyproject.toml (PoetryやPDMの場合) の雛形が作成されていること。  
* **テスト**: 仮想環境内でPythonのバージョンが確認できること。

### **[x] 0.2. 依存ライブラリインストール準備**

* **タスク内容**: プロジェクトで利用する主要ライブラリ（LangGraph, YAMLパーサー(PyYAML等), JSONパーサー(標準json), Pydantic(データクラス用、推奨)）を特定し、インストール手順を確立する。  
* **完了条件**:  
  * 必要なライブラリがリストアップされていること。  
  * requirements.txt 等に追記され、pip install -r requirements.txt 等で一括インストールできること。  
* **テスト**: 仮想環境に指定ライブラリがインストールされ、importできること。

### **[x] 0.3. プロジェクトディレクトリ構造作成**

* **タスク内容**: 「詳細仕様書 5. フォルダ構成案」に基づいて、プロジェクトの基本的なディレクトリ構造を作成する。  
* **完了条件**:  
  * project_anima/  
  * project_anima/core/  
  * project_anima/characters/  
  * project_anima/scenes/  
  * project_anima/logs/  
  * project_anima/prompts/  
  * project_anima/utils/  
  * 各ディレクトリが作成されていること。  
* **テスト**: treeコマンド等でディレクトリ構造が仕様書通りであることを確認。

### **[x] 0.4. バージョン管理システム初期化**

* **タスク内容**: Gitリポジトリを初期化し、基本的な.gitignoreファイルを作成する。  
* **完了条件**:  
  * .gitディレクトリが作成されていること。  
  * Pythonの仮想環境、キャッシュファイル (__pycache__, .pyc) 、ログファイル、IDE設定ファイルなどが無視されるように.gitignoreが設定されていること。  
* **テスト**: git statusで不要なファイルが追跡対象外になっていることを確認。

## **フェーズ1: 基本データ構造とファイルI/O**

### **[x] 1.1. データクラス定義 (Pydantic等)**

* **タスク内容**: 「詳細仕様書 3.2.2. コンテクスト管理」および「4.1. データ構造」で定義されたデータ構造（ImmutableCharacterData, LongTermCharacterData, SceneData, TurnData, InterventionDataなど）に対応するPythonのデータクラスを定義する（Pydanticの使用を強く推奨）。  
* **完了条件**:  
  * 各データ構造に対応するデータクラスが core/data_models.py (仮)のようなファイルに定義されていること。  
  * 型ヒントが付与され、バリデーションが設定されていること（Pydanticの場合）。  
* **テスト**: 各データクラスのインスタンス生成と、サンプルデータを用いたバリデーションが成功すること。

### **[x] 1.2. YAML/JSONファイルハンドラ実装 (utils/file_handler.py)**

* **タスク内容**: YAMLファイルおよびJSONファイルの読み込み・書き込みを行うユーティリティ関数を実装する。  
* **完了条件**:  
  * load_yaml(file_path): YAMLファイルを読み込みPythonオブジェクトを返す関数。  
  * save_yaml(data, file_path): PythonオブジェクトをYAMLファイルに書き込む関数。  
  * load_json(file_path): JSONファイルを読み込みPythonオブジェクトを返す関数。  
  * save_json(data, file_path): PythonオブジェクトをJSONファイルに書き込む関数。  
  * エラーハンドリング（ファイルが見つからない場合、パースエラー等）が実装されていること。  
* **テスト**:  
  * サンプルYAML/JSONファイルの読み込み・書き込みが正しく行えること。  
  * 不正なファイルパスや内容の場合に適切にエラーが処理されること。

### **[ ] 1.3. キャラクター設定ファイルの読み込み (core/character_manager.py)**

* **タスク内容**: CharacterManagerクラスに、指定されたキャラクターのimmutable.yamlとlong_term.yamlを読み込み、対応するデータクラスのインスタンスとして保持する機能を実装する。  
* **クラス**: CharacterManager  
  * load_character_data(self, character_id): 指定Character_IDに対応するYAMLファイルを読み込み、内部に保持。  
  * get_immutable_context(self, character_id): 不変情報を返す。  
  * get_long_term_context(self, character_id): 長期情報を返す。  
* **完了条件**:  
  * サンプルキャラクターのYAMLファイルを正しく読み込み、データクラスのインスタンスとしてアクセスできること。  
  * 存在しないキャラクターIDが指定された場合にエラー処理が行われること。  
* **テスト**:  
  * ユニットテストで、サンプルYAMLからのデータロードと取得が正しく行えることを確認。  
  * ファイル欠損時のエラーハンドリングを確認。

### **[x] 1.4. 場面設定ファイルの読み込み (core/scene_manager.py)**

* **タスク内容**: SceneManagerクラスに、指定された場面設定YAMLファイル (scenes/<scene_id>.yaml) を読み込み、対応するデータクラスのインスタンスとして保持する機能を実装する。  
* **クラス**: SceneManager  
  * load_scene_from_file(self, scene_file_path): 場面設定ファイルを読み込み、内部に保持。  
  * get_current_scene_info(self): 現在の場面情報を返す。  
* **完了条件**:  
  * サンプル場面のYAMLファイルを正しく読み込み、データクラスのインスタンスとしてアクセスできること。  
* **テスト**:  
  * ユニットテストで、サンプルYAMLからのデータロードと取得が正しく行えることを確認。

## **フェーズ2: コアロジック - コンテクスト構築とLLM連携準備**

### **[x] 2.1. コンテクストビルダー基本実装 (core/context_builder.py)**

* **タスク内容**: ContextBuilderクラスの基本構造と、各コンテクスト情報を整形するプライベートメソッドの雛形を実装する。  
* **クラス**: ContextBuilder  
  * __init__(self, character_manager, scene_manager)  
  * build_context_for_character(self, character_id, current_scene_short_term_log, previous_scene_summary=None): メインのコンテクスト構築メソッド。  
  * _format_immutable_context(self, immutable_data)  
  * _format_long_term_context(self, long_term_data)  
  * _format_scene_context(self, scene_data)  
  * _format_short_term_context(self, short_term_log)  
* **完了条件**:  
  * 各メソッドが呼び出し可能で、ダミーの整形済みコンテクスト文字列（または構造化データ）を返すこと。  
  * CharacterManagerとSceneManagerから必要な情報を取得する処理の呼び出し部分が実装されていること。  
* **テスト**:  
  * ユニットテストで、ダミーデータを用いて各フォーマットメソッドが期待通りの形式（文字列や辞書など）で値を返すことを確認。

### **[x] 2.2. プロンプトテンプレート準備 (prompts/)**

* **タスク内容**: 「詳細仕様書 3.2.1」で言及されている思考生成プロンプト (think_generate.txt) と長期情報更新プロンプト (long_term_update.txt) の基本的なテンプレートファイルを作成する。プレースホルダー（例: {{character_name}}, {{immutable_context}}など）を定義する。  
* **完了条件**:  
  * prompts/think_generate.txt が作成されていること。  
  * prompts/long_term_update.txt が作成されていること。  
  * 各テンプレートに、コンテクスト情報を埋め込むためのプレースホルダーが定義されていること。  
* **テスト**: 目視確認。

### **[x] 2.3. LLMアダプター基本実装 (core/llm_adapter.py)**

* **タスク内容**: LLMAdapterクラス（またはLangGraphのGraph構築関数群）の基本構造を実装する。LLM APIクライアントの初期化部分と、プロンプトテンプレートを読み込む処理を実装する。  
* **クラス/関数**: LLMAdapter  
  * __init__(self, api_key=None, model_name="gemini-pro") (または同等の設定読み込み)  
  * 思考生成・長期情報更新メソッドの雛形 (generate_character_thought, update_character_long_term_info)。  
  * LangGraphの基本的なグラフ構造の雛形。  
* **完了条件**:  
  * LLMクライアントが初期化できること（APIキーはダミーや環境変数経由でも可）。  
  * プロンプトテンプレートファイルを読み込めること。  
* **テスト**:  
  * ユニットテストで、プロンプトテンプレートの読み込みが成功することを確認。  
  * (モックを使用して)LLM API呼び出し部分がエラーなく実行される（ダミーレスポンスを返す）ことを確認。

## **フェーズ3: シミュレーションエンジンの基本ループと情報更新**

### **[x] 3.1. 情報更新モジュール基本実装 (core/information_updater.py)**

* **タスク内容**: InformationUpdaterクラスの基本メソッドを実装する。短期ログへのターン記録、介入記録機能。  
* **クラス**: InformationUpdater  
  * record_turn_to_short_term_log(...)  
  * record_intervention_to_log(...)  
* **完了条件**:  
  * 渡されたデータをメモリ上の短期ログ（場面ログデータ構造）に追加・更新できること。  
* **テスト**:  
  * ユニットテストで、ターンデータや介入データが正しく短期ログに追加されることを確認。

### **[x] 3.2. シミュレーションエンジンコア実装 (core/simulation_engine.py)**

* **タスク内容**: SimulationEngineクラスのコアロジック（シミュレーション開始、ターン進行管理、次のキャラクター決定）を実装する。コンテクスト構築、LLM呼び出し、情報更新の各モジュールを呼び出す流れを作る。  
* **クラス**: SimulationEngine  
  * __init__(self, scene_file_path): CharacterManager, SceneManager, ContextBuilder, LLMAdapter, InformationUpdaterを初期化。  
  * start_simulation(self): 場面情報をロードし、シミュレーションループを開始。  
  * next_turn(self): ターン処理のメインロジック。  
    1. _determine_next_character() で次のキャラ決定。  
    2. context_builder.build_context_for_character() でコンテクスト構築。  
    3. llm_adapter.generate_character_thought() で思考・行動・発言取得 (ダミー応答でOK)。  
    4. information_updater.record_turn_to_short_term_log() で短期ログ更新。  
    5. _log_turn_data() (仮) でコンソール等にターン情報を表示。  
* **完了条件**:  
  * 指定された場面設定でシミュレーションが開始され、参加キャラクターが順番にダミーの思考・行動・発言を行うデモが実行できること。  
  * 各ターンの情報がメモリ上の短期ログに記録されること。  
* **テスト**:  
  * 簡単な場面設定とキャラクター設定ファイルを用意し、数ターン分のシミュレーションがエラーなく実行され、期待される順序でキャラクターが行動することを確認。  
  * コンソール出力やデバッガで、各モジュールが呼び出され、データが渡されていることを確認。

### **[ ] 3.3. ログ出力機能 (core/simulation_engine.py, utils/file_handler.py)**

* **タスク内容**: 場面終了時に、メモリ上の短期ログ（場面ログ）を指定されたJSON/YAML形式でファイルに出力する機能 (_save_scene_log) を実装する。  
* **完了条件**:  
  * シミュレーション終了後（または場面終了時）に、logs/<simulation_id>/scene_<scene_id>.json (または .yaml) が生成されること。  
  * ファイルの内容が「詳細仕様書 3.2.2 短期情報(ログファイル構造)」の形式に沿っていること。  
* **テスト**:  
  * 数ターンのシミュレーションを実行し、生成されたログファイルの内容が正しいか確認。

## **フェーズ4: LLM連携と本格的な思考生成**

### **[ ] 4.1. 思考生成プロンプト詳細化とコンテクスト整形 (core/context_builder.py, prompts/think_generate.txt)**

* **タスク内容**: think_generate.txt の内容を具体化し、ContextBuilder の各フォーマットメソッドを実装して、LLMがキャラクターの思考・行動・発言を生成するために必要な情報を過不足なく、かつ効果的にプロンプトに埋め込めるようにする。  
* **完了条件**:  
  * ContextBuilder が、実際のキャラクターデータと場面データから、LLMへの入力として適切に整形されたプロンプト文字列を生成できること。  
  * プロンプトが、不変情報、長期情報（経験、目標、記憶）、場面情報、短期情報（会話履歴）をバランス良く含んでいること。  
* **テスト**:  
  * ユニットテストで、様々なパターンのキャラクター・場面データに対して、期待される構造と内容のプロンプトが生成されることを確認。  
  * 生成されたプロンプトを目視で確認し、LLMが解釈しやすい内容になっているか評価。

### **[ ] 4.2. LLM API連携による思考生成 (core/llm_adapter.py)**

* **タスク内容**: LLMAdapter の generate_character_thought メソッドを本格的に実装し、LangGraph経由で実際にLLM API (Gemini or OpenAI) を呼び出し、思考・行動・発言のJSON応答を取得できるようにする。エラーハンドリング（APIエラー、タイムアウト、不正なJSON応答など）も実装する。  
* **完了条件**:  
  * 整形されたプロンプトをLLM APIに送信し、JSON形式の応答（{"think": "...", "act": "...", "talk": "..."}）を正しく受信・パースできること。  
  * APIエラー発生時に適切な例外処理が行われること。  
* **テスト**:  
  * (実際のAPIキーを設定し)簡単なプロンプトでLLM APIを呼び出し、期待される形式の応答が得られることを確認。  
  * 意図的に不正なプロンプトや設定で呼び出し、エラーハンドリングが機能することを確認。

### **[ ] 4.3. シミュレーションエンジンへの思考生成組み込み (core/simulation_engine.py)**

* **タスク内容**: SimulationEngine の next_turn メソッド内で、ダミーの思考生成処理を、実際に LLMAdapter を使った思考生成に置き換える。  
* **完了条件**:  
  * シミュレーション実行時、各キャラクターがLLMによって生成された思考・行動・発言を行うようになること。  
  * 生成された内容が短期ログに正しく記録されること。  
* **テスト**:  
  * 簡単なシナリオでシミュレーションを実行し、キャラクターの行動がLLMによって生成されたそれらしいものになっているか確認。  
  * ログファイルの内容が正しいか確認。

## **フェーズ5: 長期情報の更新とユーザー介入**

### **[ ] 5.1. 長期情報更新プロンプトとLLM連携 (core/context_builder.py, core/llm_adapter.py, prompts/long_term_update.txt)**

* **タスク内容**: 長期情報（経験、目標、記憶）を更新するためのLLMプロンプト (long_term_update.txt) を作成し、LLMAdapter に長期情報更新メソッド (update_character_long_term_info) を実装する。このメソッドは、現在の場面ログやキャラクターの既存の長期情報を元に、更新すべき長期情報（新しい経験、目標の変更、新しい記憶など）の案をLLMに生成させる。  
* **完了条件**:  
  * LLMが、入力情報に基づいて長期情報の更新案（例: 新しい経験の記述、更新された目標リストなど）を構造化データ（JSONなど）で提案できるようになること。  
* **テスト**:  
  * ユニットテストで、サンプルデータから長期情報更新プロンプトが生成され、LLM（モックまたは実API）から期待される形式の更新案が返ってくることを確認。

### **[ ] 5.2. 長期情報更新の実行と保存 (core/information_updater.py, core/character_manager.py)**

* **タスク内容**: InformationUpdater に trigger_long_term_update メソッドを実装。ユーザーからの指示に基づき、LLMAdapter を使って長期情報の更新案を取得し、CharacterManager を介して該当キャラクターの long_term.yaml ファイルに保存する。  
* **完了条件**:  
  * ユーザーが指示した際に、指定キャラクターの長期情報がLLMの提案に基づいて更新され、ファイルに永続化されること。  
  * 更新前後のデータ比較で、正しく変更が反映されていること。  
* **テスト**:  
  * シミュレーション中にユーザー指示で長期情報更新を実行し、対応するYAMLファイルが期待通りに更新されることを確認。

### **[ ] 5.3. ユーザー介入機能の実装 (core/simulation_engine.py, core/scene_manager.py)**

* **タスク内容**: 「詳細仕様書 3.2.3」に記載されたユーザー介入機能（場面状況介入、天啓付与など）を SimulationEngine および関連モジュールに実装する。介入内容はログに記録する。  
  * **ターン進行**: SimulationEngine のメインループで実装済み。  
  * **長期情報更新指示**: SimulationEngine から InformationUpdater の trigger_long_term_update を呼び出すインターフェースを実装。  
  * **場面状況介入**: SceneManager に場面情報を更新するメソッドを実装し、SimulationEngine から呼び出す。  
  * **天啓付与**: SimulationEngine で天啓情報を準備し、次ターンの ContextBuilder がそれをコンテクストに含めるようにする。  
* **完了条件**:  
  * コンソール等から各介入コマンド（仮）を実行すると、シミュレーションの状態やキャラクターの次の行動に影響が与えられること。  
  * 介入情報がログファイルに正しく記録されること。  
* **テスト**:  
  * 各介入パターンを実際に試し、シミュレーションが期待通りに変化すること、ログが正しく記録されることを確認。

## **フェーズ6: オプション機能と仕上げ**

### **[ ] 6.1. (オプション) 直前場面の短期情報引き継ぎ実装**

* **タスク内容**: 「詳細仕様書 3.2.1 (オプション)」に基づき、直前の場面の短期情報を次の場面のコンテクストに含める機能を実装する。要約処理が必要な場合はそれも実装する。  
* **完了条件**:  
  * 設定に応じて、直前場面の情報が次場面のキャラクターの初期行動に影響を与えること。  
  * コンテクスト長が過大にならないように制御されていること。  
* **テスト**: 複数の場面を連続で実行し、場面間の情報の連続性が確認できるかテスト。

### **[ ] 6.2. (オプションS) 過去場面/ターンへの復帰機能**

* **タスク内容**: 「機能No.8」に基づき、過去のログ状態を復元し、そこからシミュレーションを再開できる機能を実装する（状態のスナップショットと復元ロジック）。  
* **完了条件**:  
  * 指定した過去の場面・ターンからシミュレーションを再開できること。  
* **テスト**: 実際に過去に戻って異なる介入を行い、物語が分岐することを確認。

### **[ ] 6.3. (オプションS) 思考プロセス可視化機能**

* **タスク内容**: 「機能No.9」に基づき、LLMがコンテクストのどの部分を重視したか等のデバッグ情報を（可能な範囲で）出力する機能を検討・実装する。  
* **完了条件**:  
  * キャラクターの思考の根拠に関する何らかの情報が得られること。  
* **テスト**: 出力された情報が、キャラクターの行動を理解する上で役立つか評価。

### **[ ] 6.4. (オプションS) 感情・関係性変化レポート機能**

* **タスク内容**: 「機能No.16」に基づき、ログ全体からキャラクターの感情や関係性の変化を（簡易的にでも）分析し、レポートとして出力する機能を検討・実装する。  
* **完了条件**:  
  * シミュレーションログから、キャラクターの感情や関係性に関する傾向が読み取れるレポートが出力されること。  
* **テスト**: 生成されたレポートが物語の分析に役立つか評価。

### **[ ] 6.5. (オプションC) 特定キャラ視点ログ出力機能**

* **タスク内容**: 「機能No.15」に基づき、ログ出力時に特定のキャラクターの思考・行動・発言のみを抽出して出力するオプションを実装する。  
* **完了条件**:  
  * 指定したキャラクターの視点に絞ったログが出力されること。  
* **テスト**: 出力されたログが指定キャラクターの行動のみを含んでいることを確認。

### **[ ] 6.6. 全体テストとリファクタリング**

* **タスク内容**: システム全体の動作テスト、パフォーマンスチェック、コードのリファクタリング、ドキュメント整備を行う。  
* **完了条件**:  
  * 主要機能が仕様書通りに安定して動作すること。  
  * コードが整理され、可読性が向上していること。  
  * 簡単な操作マニュアルやREADMEが整備されていること。  
* **テスト**: 複数のシナリオで長時間シミュレーションを実行し、安定性や予期せぬエラーがないか確認。